# modelmachine
Model machine emulator

[![Build Status](https://travis-ci.org/vslutov/modelmachine.svg?branch=master)](https://travis-ci.org/vslutov/modelmachine)

## TODO

* УМ-Р (регистровая)
* УМ с модификацией адресов ???

* Изменить базовую концепцию memory->integer и переписать модули
* Добавить test.alu.swap
* Работа с плавающей запятой
* Подумать еще о mock в тестах
* Подумать о команде остановки halt
* Переделать документацию модулей
* Исправить опечатки в документации
* Расширить howto
* ГУИ

## Модельная машина

Модельная машина - это чистая архитектурная концепция, позволяющая понять
логику функционирования центральных процессоров. По своей структуре она близка
к компьютерам первого поколения. Подробнее читайте по ссылкам внизу.

## Quickstart

Установка пакета происходит командой:

    # python3 -m pip install --upgrade modelmachine

После этого вам становится доступна консольная команда `modelmachine`.
Для проверки вы можете сделать `modelmachine test`. Будет выполнена
серия тестов, все тесты должны закончиться успехом.

Посмотрите примеры в папке <samples>, по их образу можно начинать писать
программы для модельных машин. Запуск программы делается командой:

    $ modelmachine run program.mmach

Также доступна пошаговая отладка командой:

    $ modelmachine debug program.mmach

### Пример

    bordachenkova_mm3

    [config]
    input = 0x100,0x101
    output = 0x103

    [code]
    ; x = ((a * -21) % 50 - b) ** 2 == 178929
    03 0100 0005 0103 ; x := a * -21
    04 0103 0006 0102 ; [0102] := x / 50, x := x % 50
    02 0103 0101 0103 ; x := x - b
    03 0103 0103 0103 ; x := x * x
    99 0000 0000 0000 ; halt
    ; ---------------------
    FFFFFFFFFFFFEB ; -21
    00000000000032 ; 50

    [input]
    -123 456

* Первая строчка - обязательное название архитектуры. Список поддерживаемых
  архитектур смотри ниже.
* После этого должна идти секция `config`, описывающая ячейки памяти,
  по которым нужно производить ввод и вывод.
* После этого секция кода, содержащая набор 16-ричных чисел, записываемых в
  память модельной машины. Пропускать часть машинного слова нельзя.
  Рекомендуется писать по одному машинному слову в строке, по желанию
  разбивая разряды на части пробелами.
* Все, что идет после символа `;` - комментарий.
* Пустые строки игнорируются.
* После этого идет секция ввода - несколько чисел, разделенных пробельными
  символами. Их число должно совпадать с числом ячеек для ввода в параметре
  `input` в секции `config`.
* По окончании работы на экран будут напечатаны десятичные числа со знаком,
  лежащие в ячейках, перечисленных в параметре `output` в секции `config`.

## Внутреннее устройство

Данная реализация модельной машины состоит из классов, разбитых на
файлы-модули:

* `memory.py` - память; делится на два класса: `регистровая` и
  `оперативная`; оперативная делится на `little-endian` и `big-endian`
* `numeric.py` - целочисленная арифметика с фиксированным числом
  двоичных знаков
* `alu.py` - арифметико-логическое устройство, работает с четко
  специализированными регистрами: `R1`, `R2`, `S`, `FLAGS` и `IP`.
* `cu.py` *в процессе реализации* - контролирующее устройство, выполняющее
  считывание команд из памяти и запускающее необходимые методы в
  арифметико-логическом устройстве
* `io.py` - устройство ввода-вывода
* `cpu.py` - финальное объединение составляющих устройств в единое целое

Здесь дано поверхностное описание модулей. За более подробным
обращайтесь к документации конкретных модулей и их исходным кодам.

### memory.py

`AbstractMemory` - класс абстрактной памяти, предоставляющий интерфейс для
надежной связи частей компьютера. Основные методы: `fetch` и `put`, которые
принимают на вход адрес в памяти и количество битов, с которыми нужно работать,
количество должно быть кратно размеру ячейки (слова). Строго
рекомендуется их использовать везде.

`RandomAccessMemory` - класс, реализующий память прямого доступа. При
инициализации указывается размер машинного слова и количество этих слов. Если
`is_protected=True`, то при попытке считывания из неинициализированной ячейки
будет выброшено исключение, иначе, метод `fetch` вернет нуль.

`RegisterMemory` - класс, реализующий регистровую память. Метод `add_register`
добавляет регистр определенного размера или проверяет, что уже добавленный
регистр имеет правильный размер.

### numeric.py

Класс Integer реализует целочисленную арифметику фиксированной длины.
Поддерживаемые операторы: `+`, `-`, `*`, `/`, `%`, `==`, `!=`. Плюс методы
`get_value` и `get_data`. Округление при делении производится в сторону нуля.

### alu.py

Арифметико-логическое устройство работает с четко специализированными
регистрами:

* `R1`, `R2`, `S` для арифметических операций.
* `FLAGS` для хранения флагов состояния.
* `IP` *только* для пересылки туда адреса из регистра `R1` при условных
  переходах.

Схема работы:

* Арифметические команды: `add`, `sub`, `smul`, `sdiv`, `umul`, `udiv`,
  `sdivmod`, `udivmod`. За исключением команд `divmod` арифметические
  команды работают следующим образом: `S := R1 op R2`.
  Плюс в зависимости от результата выставляется регистр `FLAGS` - комбинация
  флагов CF, OF, SF и ZF.
* `add` и `sub` - сложение и вычитание соответсвенно.
* `smul` и `sdiv` - знаковое умножение и деление соответсвенно.
* `umul` и `udiv` - беззнаковое умножение и деление соответсвенно.
* `sdivmod` и `udivmod` - знаковое и беззнаковое соответственно деление с
  остатком. `S := R1 / R2; R1 := R1 % R2`.
* Команда пересылки `move`: `S := R1`.
* Команды безусловного перехода `jump` и условного перехода `cond_jump`
  работают по схеме `IP := R1`, режим работы `cond_jump` зависит от того,
  какие дополнительные аргументы будут переданы.
* Команда останова `halt` просто выставляет флаг остановки HALT в
  регистре флагов

### cu.py

Управляющее устройство.

#### AbstractControlUnit

Обычно управляющее устройство работает по схеме:

1. `fetch_and_decode` - загрузка и расшифровка очередной команды.
   Содержимое ячейки оперативной памяти с адресом записанным
   в регистре `IP` загружается в регистр `IR`, затем из него извлекается
   код операции и адреса операндов, затем счетчик `IP` увеличивается на
   длину только что считанной команды.
2. `load` - данные по только что считанным адресам загружаются в регистры
   процессора `R1` и `R2`
3. `execute` - в зависимости от кода операции в арифметико-логическом
   устройстве запускается та или иная схема вычислений.
4. `write_back` - результат вычислений записывается куда полагается (например,
   по одному из адресов считанных в начале).

Все эти методы поддерживаются в `AbstractControlUnit`.
Также в нем написаны использующие их методы, являющиеся интерфейсом
устройства управления:

* `step` - сделать один шаг, описанный алгоритмом выше.
* `get_status` - вернуть статус процессора (выполняется/остановлен).
  Остановка производится командой останова `halt`.
* `run` - выполнять один шаг за другим, пока процессор не будет остановлен.

Далее, наследники `AbstractControlUnit` определяют первые 4 метода.

### io.py

Устройство ввода-вывода.

* При инициализации устанавливается адрес с которого нужно загружать
  программы пользователя.
* Метод `load_source` загружает последовательность шеснадцатиричных слов
  по указанному адресу.
* Метод `load_data` загружает данные (полученные из строки чисел)
  по данным адресам.
* Методы `get_int` и `put_int` работают с содержимым одного слова.
  Размер слова устанавливается при инициализации.

### cpu.py

Финальная сборка всех составных устройств в единое целое.

* Поддерживается доступ к составным устройствам. Например, доступ
  к устройству ввода/вывода можно получить через `cpu.io_unit`,
  к регистрам через `cpu.registers` и так далее.
* `load_program` - загрузка программы, конфигурации и данных в оперативную
  память.
* `print_result` - печать результата работы программы.
* `run_file` - загрузка, исполнение и печать результата.

## Поддерживаемые архитектуры

### Как добавить новую архитектуру?

1. Выписать все команды устройстройства и их коды.
2. Добавить их в таблицу ниже и описание еще ниже.
3. Добавить новый класс устройства управления на основе существующего.
4. Добавить новый класс CPU использующий это устройство управления,
   добавить этот класс в список `CPU_LIST` в файле `cpu.py`.
5. Добавить тесты для обоих этих классов в файлы `tests/test_cu.py` и
   `tests/test_cpu.py`.
6. Добавить примеры в папку `samples`.
7. Прислать pull request.

### Таблица команд модельных машин

|OPCODE|mm-3 |mm-2 |mm-v |mm-1 |mm-st |
|:-----|:---:|:---:|:---:|:---:|:----:|
|0x00  |move |move |move |load |      |
|0x01  | add | add | add | add | add  |
|0x02  | sub | sub | sub | sub | sub  |
|0x03  |smul |smul |smul |smul | smul |
|0x04  |sdiv |sdiv |sdiv |sdiv | sdiv |
|0x05  |     |comp |comp |comp | comp |
|0x13  |umul |umul |umul |umul | umul |
|0x14  |udiv |udiv |udiv |udiv | udiv |
|0x10  |     |     |     |store|      |
|0x20  |     |     |     |swap |      |
|0x5A  |     |     |     |     |stpush|
|0x5B  |     |     |     |     |stpop |
|0x5C  |     |     |     |     |stdup |
|0x5D  |     |     |     |     |stswap|
|0x80  |jump |jump |jump |jump | jump |
|0x81  | jeq | jeq | jeq | jeq | jeq  |
|0x82  |jneq |jneq |jneq |jneq | jneq |
|0x83  | sjl | sjl | sjl | sjl | sjl  |
|0x84  |sjgeq|sjgeq|sjneq|sjgeq|sjgeq |
|0x85  |sjleq|sjleq|sjleq|sjleq|sjleq |
|0x86  | sjg | sjg | sjg | sjg | sjg  |
|0x93  | ujl | ujl | ujl | ujl | ujl  |
|0x94  |ujgeq|ujgeq|ujgeq|ujgeq|ujgeq |
|0x95  |ujleq|ujleq|ujleq|ujleq|ujleq |
|0x96  | ujg | ujg | ujg | ujg | ujg  |
|0x99  |halt |halt |halt |halt | halt |

На самом деле операция `div` запускает в АЛУ схему `divmod`.

Ниже дана таблица команд условных переходов.
Откуда берутся операнды для сравнения зависит от архитектуры модельной
машины. Подробнее смотри *[1]*.

|Мнемонический код|Условие перехода|Расшифровка/описание             |
|:----------------|:--------------:|:--------------------------------|
|jeq              |      ==        |jump if equal                    |
|jneq             |      !=        |jump if not equal                |
|sjl              |     <  s       |signed jump if less              |
|sjgeq            |     >= s       |signed jump if greater or equal  |
|sjleq            |     <= s       |signed jump if less or equal     |
|sjg              |     >  s       |signed jump if greater           |
|ujl              |     <  u       |unsigned jump if less            |
|ujgeq            |     >= u       |unsigned jump if greater or equal|
|ujleq            |     <= u       |unsigned jump if less or equal   |
|ujg              |     >  u       |unsigned jump if greater         |

### bordachenkova_mm3

Архитектура трехадресной модельной машины.

* Размер ячейки оперативной памяти: 7 байт.
* Размер адреса: 2 байта.
* Арифметические вычисления производятся с одной ячейкой оперативной памяти.
* Код команды помещается в одну ячейку оперативной памяти `КОП А1 А2 А3`.
* Регистры: `S`, `R1`, `R2`, `FLAGS`, `IP`, `IR`, `ADDR`.

Назначение регистров:

* `S` - регистр сумматор, в него записывается результат арифметической операции.
* `R1`, `R2` - регистры операндов арифметических операций.
* `FLAGS` - регистр флагов.
* `IP` - регистр указатель инструкции.
* `IR` - регистр для хранения инструкции.
* `ADDR` - регистр для хранения адреса для инструкции перехода.

Действия процессора для арифметических инструкций (`add`, `sub`,
`smul`, `sdiv`, `umul`, `udiv`) `КОП A1 A2 A3`:

1. Загрузить содержимое ячейки оперативной памяти с адресом `А1` в
   регистр `R1` (`R1 := [A1]`).
2. Загрузить содержимое ячейки оперативной памяти с адресом `А2` в
   регистр `R2` (`R2 := [A2]`).
3. Запустить в АЛУ схему, реализующую операцию, задаваемую `КОП`.
4. Записать результат из регистра `S` в ячейку оперативной памяти с
   адресом `А3`.
   Если выполняется операция деления, в оперативную память записываются
   два результата: частное – в ячейку с адресом `А3`, остаток – в следующую
   ячейку, по адресу `(А3+1) mod 16^4`.

* `jump A1 A2 A3`: `IP := A3`
* Условные переходы: сравниваются `R1` и `R2`, в зависимости от результата
  происходит `IP := A3`.
* Команда пересылки `move`: [A3] := R1.

### bordachenkova_mm2

Архитектура двухадресной модельной машины.

* Размер ячейки оперативной памяти: 5 байт.
* Размер адреса: 2 байта.
* Арифметические вычисления производятся с одной ячейкой оперативной памяти.
* Код команды помещается в одну ячейку оперативной памяти `КОП А1 А2`.
* Регистры: `R1`, `R2`, `FLAGS`, `IP`, `IR`, `ADDR`.

Действия для арифметических команд `add`, `sub`, `smul`, `sdiv`, `umul`,
`udiv`:

1. `R1 := [A1], R2 := [A2]`
2. `R1 := R1 op R2`
3. `[A1] := R1`

Действия для команды сравнения `cmp`:

1. `R1 := [A1], R2 := [A2]`
2. Запустить в АЛУ схему `sub`, выставить регистр `FLAGS`

* `jump A1 A2`: `IP := A2`
* Условные переходы делаются исходя из регистра `FLAGS`
* `move A1 A2`: `[A1] := [A2]`
* Команда останова `halt` взводит флаг `HALT` в регистре `FLAGS`

### bordachenkova_mmv

Архитектура модельной машины с переменным (variable) фарматом команд.

* Размер ячейки оперативной памяти: 1 байт.
* Размер адреса: 2 байта.
* Арифметические вычисления производятся со словами в 5 ячеек оперативной
  памяти.
* Код команды занимает разное количество ячеек в зависимости от выполняемой
  операции.
* Регистры: `R1`, `R2`, `FLAGS`, `IP`, `IR`, `ADDR`.

Таблица кодов команд:

|Код команды|Мнемоник|Формат    |Длина (в байтах)|
|:----------|:------:|:---------|---------------:|
|0x00       |move    |move A1 A2|               5|
|0x01       |add     |add  A1 A2|               5|
|0x02       |sub     |sub  A1 A2|               5|
|0x03       |smul    |smul A1 A2|               5|
|0x04       |sdiv    |sdiv A1 A2|               5|
|0x05       |comp    |comp A1 A2|               5|
|0x13       |umul    |umul A1 A2|               5|
|0x14       |udiv    |udiv A1 A2|               5|
|0x80       |jump    |jump  A1  |               3|
|0x81       |jeq     |jeq   A1  |               3|
|0x82       |jneq    |jneq  A1  |               3|
|0x83       |sjl     |sjl   A1  |               3|
|0x84       |sjgeq   |sjgeq A1  |               3|
|0x85       |sjleq   |sjleq A1  |               3|
|0x86       |sjg     |sjg   A1  |               3|
|0x93       |ujl     |ujl   A1  |               3|
|0x94       |ujgeq   |ujgeq A1  |               3|
|0x95       |ujleq   |ujleq A1  |               3|
|0x96       |ujg     |ujg   A1  |               3|
|0x99       |halt    |halt      |               1|

Действия для арифметических команд `add`, `sub`, `smul`, `sdiv`, `umul`,
`udiv`:

1. `R1 := [A1], R2 := [A2]`
2. `R1 := R1 op R2`
3. `[A1] := S`

Действия для команды сравнения `cmp`:

1. `R1 := [A1], R2 := [A2]`
2. Запустить в АЛУ схему `sub`, выставить регистр `FLAGS`

* `jump A1`: `IP := A1`
* Условные переходы делаются исходя из регистра `FLAGS`
* `move A1 A2`: `[A1] := [A2]`
* Команда останова `halt` взводит флаг `HALT` в регистре `FLAGS`

### bordachenkova_mm1

Архитектура одноадресной модельной машины.

* Размер ячейки оперативной памяти: 3 байта.
* Размер адреса: 2 байта.
* Арифметические вычисления производятся с одной ячейкой оперативной памяти.
* Код команды помещается в одну ячейку оперативной памяти `КОП А`.
* Регистры: `S`, `R`, `S1`, `FLAGS`, `IP`, `IR`.

Регистры `S` и `S1` хранят информацию постоянно, а не затираются при
выполнении очередной команды, как было раньше. В регистр `R` закгружается
операнд для арифметических операций.

Действия для арифметических команд (исключая деление) `add`, `sub`, `smul`,
`umul`:

1. `R := [A]`
2. `S := S op R`

Действия для команд деления `sdivmod`, `udivmod`:

1. `R := [A]`
2. `S := S / R; S1 := S % R`

Действия для команды сравнения `cmp`:

1. `R := [A]`
2. Запустить в АЛУ схему `sub`, выставить регистр `FLAGS`

* `jump A`: `IP := A`
* Условные переходы делаются исходя из регистра `FLAGS`
* `load A`: `S := [A]`
* `store A`: `[A] := S`
* `swap`: `S, S1 := S1, S`
* Команда останова `halt` взводит флаг `HALT` в регистре `FLAGS`

### bordachenkova_mmst

Архитектура стековой (stack) модельной машины.

* Размер ячейки оперативной памяти: 1 байт.
* Размер адреса: 2 байта.
* Арифметические вычисления производятся со словом в 3 байта.
* Код команды занимает разное количество ячеек в зависимости от выполняемой
  операции. Большинство команд безадресные, имеют формат `КОП` и занимают
  1 байт. Некоторые команды работы со стеком и команды перехода имеют
  один операнд, формат `КОП А` и занимают 3 байта.
* Регистры: `R1`, `R2`, `FLAGS`, `IP`, `IR`, `SP`.

Регистр `SP` - указатель стека (stack pointer) указывает на вершину стека.

Таблица кодов команд:

|Код команды|Мнемоник|Формат   |Длина (в байтах)|
|:----------|:------:|:--------|---------------:|
|0x01       |add     |add      |               1|
|0x02       |sub     |sub      |               1|
|0x03       |smul    |smul     |               1|
|0x04       |sdiv    |sdiv     |               1|
|0x05       |comp    |comp     |               1|
|0x13       |umul    |umul     |               1|
|0x14       |udiv    |udiv     |               1|
|0x5A       |stpush  |stpush A |               3|
|0x5B       |stpop   |stpop  A |               3|
|0x5C       |stdup   |stdup    |               1|
|0x5D       |stswap  |stswap   |               1|
|0x80       |jump    |jump  A  |               3|
|0x81       |jeq     |jeq   A  |               3|
|0x82       |jneq    |jneq  A  |               3|
|0x83       |sjl     |sjl   A  |               3|
|0x84       |sjgeq   |sjgeq A  |               3|
|0x85       |sjleq   |sjleq A  |               3|
|0x86       |sjg     |sjg   A  |               3|
|0x93       |ujl     |ujl   A  |               3|
|0x94       |ujgeq   |ujgeq A  |               3|
|0x95       |ujleq   |ujleq A  |               3|
|0x96       |ujg     |ujg   A  |               3|
|0x99       |halt    |halt     |               1|

Как действует метод `push(value)`:

1. `SP -= value_size`
2. `[SP] := value`

Как действует метод `pop()`:

1. `value := [SP]`
2. `SP += value_size`
2. `return value`

Принцип работы стековых команд:

В стек `stpush A`:

1. `R1 := [A]`
2. `push(R1)`

Из стека `stpop A`:

1. `R1 := pop()`
2. `[A] := R1`

Дублирование `stdup`:

1. `R1 := pop()`
2. `push(R1); push(R1)`

Обмен `stswap`:

1. `R1 := pop(); R2 := pop()`
2. `push(R1); push(R2)`

Действия для арифметических команд (исключая деление) `add`, `sub`, `smul`,
`umul`:

1. `R2 := pop(); R1 := pop()`
2. `R1 := R1 op R2`
3. `push(R1)`

Действия для команд деления `sdivmod` и `udivmod`:

1. `R2 := pop(); R1 := pop()`
2. `R1, R2 := R1 / R2, R1 % R2`
3. `push(R1); push(R2)`

Действия для команды сравнения `cmp`:

1. `R2 := pop(), R1 := pop()`
2. Запустить в АЛУ схему `sub`, выставить регистр `FLAGS`

* `jump A1`: `IP := A1`
* Условные переходы делаются исходя из регистра `FLAGS`
* Команда останова `halt` взводит флаг `HALT` в регистре `FLAGS`

## References

1. E. А. Бордаченкова - "Модельные ЭВМ" <http://al.cs.msu.su/files/ModComp.pdf>
2. Е. А. Бордаченкова - "Архитектура ЭВМ. Учебные машины. Методическое пособие"
   <http://al.cs.msu.su/files/bordachenkova.architecture.model.machines.2010.doc>
3. В. Г. Баула - "Введение в архитектуру ЭВМ и системы программирования"
   <http://arch.cs.msu.ru/Page2.htm>
4. <http://cmcmsu.no-ip.info/1course/um3.command.set.htm>
